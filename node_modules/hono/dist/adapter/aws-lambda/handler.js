// src/adapter/aws-lambda/handler.ts
import crypto from "crypto";
globalThis.crypto = crypto;
var handle = (app) => {
  return async (event) => {
    const req = createRequest(event);
    const res = await app.fetch(req);
    return createResult(res);
  };
};
var createResult = async (res) => {
  const contentType = res.headers.get("content-type");
  const isBase64Encoded = contentType && isContentTypeBinary(contentType) ? true : false;
  const body = isBase64Encoded ? await fromReadableToString(res) : await res.text();
  const result = {
    body,
    headers: {},
    statusCode: res.status,
    isBase64Encoded
  };
  res.headers.forEach((value, key) => {
    result.headers[key] = value;
  });
  return result;
};
var createRequest = (event) => {
  const queryString = extractQueryString(event);
  const urlPath = `https://${event.requestContext.domainName}${isProxyEvent(event) ? event.path : event.rawPath}`;
  const url = queryString ? `${urlPath}?${queryString}` : urlPath;
  const headers = new Headers();
  for (const [k, v] of Object.entries(event.headers)) {
    if (v)
      headers.set(k, v);
  }
  const method = "httpMethod" in event ? event.httpMethod : event.requestContext.http.method;
  const requestInit = {
    headers,
    method
  };
  if (event.body) {
    requestInit.body = event.isBase64Encoded ? atob(event.body) : event.body;
  }
  return new Request(url, requestInit);
};
var extractQueryString = (event) => {
  if (isProxyEvent(event)) {
    return Object.entries(event.queryStringParameters || {}).filter(([, value]) => value).map(([key, value]) => `${key}=${value}`).join("&");
  }
  return isProxyEventV2(event) ? event.rawQueryString : event.rawQueryString;
};
var isProxyEvent = (event) => {
  return Object.prototype.hasOwnProperty.call(event, "path");
};
var isProxyEventV2 = (event) => {
  return Object.prototype.hasOwnProperty.call(event, "rawPath");
};
var fromReadableToString = async (res) => {
  const stream = res.body || new ReadableStream();
  const decoder = new TextDecoder();
  let string = "";
  for await (const chunk of stream) {
    string += decoder.decode(chunk);
  }
  return btoa(string);
};
var isContentTypeBinary = (contentType) => {
  return !/^(text\/(plain|html|css|javascript|csv).*|application\/(.*json|.*xml).*|image\/svg\+xml)$/.test(
    contentType
  );
};
export {
  handle,
  isContentTypeBinary
};
